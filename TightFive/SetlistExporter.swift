import SwiftUI
import UIKit

/// Handles exporting setlists in various formats.
enum SetlistExporter {
    
    /// Generate plain text export of a setlist
    static func generatePlainText(for setlist: Setlist) -> String {
        var text = ""
        
        // Title
        text += setlist.title.uppercased()
        text += "\n"
        text += String(repeating: "‚ïê", count: min(setlist.title.count, 40))
        text += "\n\n"
        
        // Bits
        if !setlist.orderedAssignments.isEmpty {
            for (index, assignment) in setlist.orderedAssignments.enumerated() {
                text += "[\(index + 1)] \(assignment.bitTitleSnapshot)\n"
                text += assignment.plainText
                text += "\n\n"
                
                if index < setlist.orderedAssignments.count - 1 {
                    text += "---\n\n"
                }
            }
        }
        
        // Notes
        if let notes = NSAttributedString.fromRTF(setlist.notesRTF)?.string,
           !notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            text += "\n"
            text += String(repeating: "‚îÄ", count: 20)
            text += "\nNOTES\n"
            text += String(repeating: "‚îÄ", count: 20)
            text += "\n\n"
            text += notes
        }
        
        // Footer
        text += "\n\n"
        text += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        text += "Generated by TightFive\n"
        text += "\(setlist.bitCount) bits"
        
        return text
    }
    
    /// Generate markdown export of a setlist
    static func generateMarkdown(for setlist: Setlist) -> String {
        var text = ""
        
        // Title
        text += "# \(setlist.title)\n\n"
        
        // Status
        text += "*\(setlist.isDraft ? "In Progress" : "Stage Ready")* ¬∑ \(setlist.bitCount) bits\n\n"
        
        // Bits
        if !setlist.orderedAssignments.isEmpty {
            text += "## Bits\n\n"
            
            for (index, assignment) in setlist.orderedAssignments.enumerated() {
                text += "### \(index + 1). \(assignment.bitTitleSnapshot)\n\n"
                text += assignment.plainText
                text += "\n\n"
            }
        }
        
        // Notes
        if let notes = NSAttributedString.fromRTF(setlist.notesRTF)?.string,
           !notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            text += "---\n\n"
            text += "## Notes\n\n"
            text += notes
            text += "\n"
        }
        
        return text
    }
    
    /// Generate a compact "cue card" format (just titles/first lines)
    static func generateCueCard(for setlist: Setlist) -> String {
        var text = ""
        
        text += "üé§ \(setlist.title)\n"
        text += String(repeating: "‚îÄ", count: 30)
        text += "\n\n"
        
        for (index, assignment) in setlist.orderedAssignments.enumerated() {
            text += "\(index + 1). \(assignment.bitTitleSnapshot)\n"
        }
        
        return text
    }
}

// MARK: - Share Sheet View

struct SetlistShareSheet: View {
    @Environment(\.dismiss) private var dismiss
    
    let setlist: Setlist
    
    @State private var selectedFormat: ExportFormat = .plainText
    @State private var showShareSheet = false
    @State private var exportedText = ""
    
    enum ExportFormat: String, CaseIterable {
        case plainText = "Full Text"
        case markdown = "Markdown"
        case cueCard = "Cue Card"
        
        var icon: String {
            switch self {
            case .plainText: return "doc.text"
            case .markdown: return "text.badge.checkmark"
            case .cueCard: return "list.bullet.rectangle"
            }
        }
        
        var description: String {
            switch self {
            case .plainText: return "Complete setlist with all content"
            case .markdown: return "Formatted for notes apps"
            case .cueCard: return "Just bit titles for quick reference"
            }
        }
    }
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Format picker
                VStack(alignment: .leading, spacing: 12) {
                    Text("EXPORT FORMAT")
                        .font(.caption.weight(.bold))
                        .foregroundStyle(.white.opacity(0.5))
                        .kerning(1.2)
                    
                    ForEach(ExportFormat.allCases, id: \.self) { format in
                        formatOption(format)
                    }
                }
                .padding(16)
                
                Divider().opacity(0.25)
                
                // Preview
                ScrollView {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("PREVIEW")
                            .font(.caption.weight(.bold))
                            .foregroundStyle(.white.opacity(0.5))
                            .kerning(1.2)
                        
                        Text(generateExport())
                            .font(.system(size: 13, design: .monospaced))
                            .foregroundStyle(.white.opacity(0.8))
                            .fixedSize(horizontal: false, vertical: true)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(16)
                }
                .background(Color.black.opacity(0.3))
                
                // Actions
                VStack(spacing: 12) {
                    Button {
                        exportedText = generateExport()
                        showShareSheet = true
                    } label: {
                        HStack {
                            Image(systemName: "square.and.arrow.up")
                            Text("Share")
                        }
                        .font(.headline)
                        .foregroundStyle(.black)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 14)
                        .background(TFTheme.yellow)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                    }
                    
                    Button {
                        UIPasteboard.general.string = generateExport()
                        dismiss()
                    } label: {
                        HStack {
                            Image(systemName: "doc.on.doc")
                            Text("Copy to Clipboard")
                        }
                        .font(.headline)
                        .foregroundStyle(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 14)
                        .background(Color("TFCard"))
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .strokeBorder(Color("TFCardStroke").opacity(0.6), lineWidth: 1)
                        )
                    }
                }
                .padding(16)
            }
            .navigationTitle("Export Setlist")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                        .foregroundStyle(TFTheme.yellow)
                }
                
                ToolbarItem(placement: .principal) {
                    TFWordmarkTitle(title: "Export", size: 20)
                }
            }
            .tfBackground()
            .sheet(isPresented: $showShareSheet) {
                ActivityViewController(activityItems: [exportedText])
            }
        }
    }
    
    private func formatOption(_ format: ExportFormat) -> some View {
        Button {
            withAnimation { selectedFormat = format }
        } label: {
            HStack(spacing: 14) {
                Image(systemName: format.icon)
                    .font(.system(size: 20))
                    .foregroundStyle(selectedFormat == format ? TFTheme.yellow : .white.opacity(0.5))
                    .frame(width: 28)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(format.rawValue)
                        .font(.headline)
                        .foregroundStyle(.white)
                    
                    Text(format.description)
                        .font(.caption)
                        .foregroundStyle(.white.opacity(0.5))
                }
                
                Spacer()
                
                if selectedFormat == format {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundStyle(TFTheme.yellow)
                }
            }
            .padding(12)
            .background(selectedFormat == format ? Color("TFCard") : Color.clear)
            .clipShape(RoundedRectangle(cornerRadius: 10))
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .strokeBorder(
                        selectedFormat == format ? TFTheme.yellow.opacity(0.5) : Color.clear,
                        lineWidth: 1
                    )
            )
        }
        .buttonStyle(.plain)
    }
    
    private func generateExport() -> String {
        switch selectedFormat {
        case .plainText:
            return SetlistExporter.generatePlainText(for: setlist)
        case .markdown:
            return SetlistExporter.generateMarkdown(for: setlist)
        case .cueCard:
            return SetlistExporter.generateCueCard(for: setlist)
        }
    }
}

// MARK: - UIKit Activity View Controller

struct ActivityViewController: UIViewControllerRepresentable {
    let activityItems: [Any]
    let applicationActivities: [UIActivity]? = nil
    
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(
            activityItems: activityItems,
            applicationActivities: applicationActivities
        )
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
